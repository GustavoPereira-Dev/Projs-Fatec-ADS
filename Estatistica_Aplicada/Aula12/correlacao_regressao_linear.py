# -*- coding: utf-8 -*-
"""correlacao_regressao_linear.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ij8jYMKJloephK5t8U800H6mKTTnjmGN

# **CORRELAÇÃO E REGRESSÃO LINEAR SIMPLES**

# **Análise e Tratamento dos Dados**
"""

import numpy as np
import pandas as pd

from google.colab import drive
drive.mount('/content/drive')

mola = pd.read_csv('/content/drive/MyDrive/Aulas Estatística (Python)/2º Bimestre/rigidez.csv',
                    sep=';', encoding='iso-8859-1')
# encoding: codificação de caracteres, normalmente utiliza-se o iso-8859-1, utf-8, latin-1)

"""**Objetivo: Analisar a correlação entre a força e a deformação sofrida por uma mola e criar um modelo de regressão linear.**"""

mola.head(40)

mola.shape

# Renomear uma variável
mola.rename(columns={'Lo': 'compr_inicial'}, inplace=True)

mola.head()

# Renomear mais de uma variável
mola.rename(columns={'L': 'compr_final','x': 'deformacao', 'K': 'rigidez'}, inplace=True)

mola.head()

# Análise dos tipos de atributos.
# object: strings
# int64: inteiros
# float64: reais
# complex: complexos
mola.dtypes

# Excluir variável
mola1 = mola.drop(columns=['compr_inicial'])
mola1.head()

"""Valores Missing (NAN)"""

# RELAÇÃO DA QUANTIDADE
mola1.isnull().sum()

mola1['deformacao'].isnull().sum()

# EXCLUIR TODOS OS VALORES MISSING
mola1 = mola1.dropna()

mola1.head()

mola1.describe()

# SUBSTITUIR OS VALORES MISSING PELA MEDIANA
mola1['compr_final'].fillna(mola1['compr_final'].median(), inplace=True)

mola1.head()

# SUBSTITUIR OS VALORES MISSING PELA MÉDIA
mola1['deformacao'].fillna(mola1['deformacao'].mean(), inplace=True)

mola1.rigidez.value_counts()

# SUBSTITUIR OS VALORES MISSING PELA MODA
mola1['rigidez'].fillna(30.81, inplace=True)

mola1.head()

"""Análise dos outliers"""

import plotly.express as px

boxplot = px.box(mola1, y="forca")
boxplot.show()

boxplot = px.box(mola1, y="deformacao")
boxplot.show()

mola1.head(30)

boxplot = px.box(mola1, y="rigidez")
boxplot.show()

mola1.head(30)

mola1.drop(28, inplace=True)

mola1.head(30)

"""# **ANÁLISE DA CORRELAÇÃO LINEAR**"""

import matplotlib.pyplot as plt

plt.scatter(mola1.deformacao,mola1.forca)
plt.title('Correlação')
plt.xlabel('Deformação')
plt.ylabel('Força')
plt.grid(False)
plt.show()

import seaborn as sns

sns.pairplot(mola1);

"""## Análise da Normalidade

Gráfico QQ-Plot
"""

import scipy.stats as stats

stats.probplot(mola1['forca'], dist="norm", plot=plt)
plt.title("Normal Q-Q plot")
plt.show()

stats.probplot(mola1['deformacao'], dist="norm", plot=plt)
plt.title("Normal Q-Q plot")
plt.show()

"""Teste Shapiro-Wilk

Ho = distribuição normal : p > 0.05

Ha = distribuição != normal : p <= 0.05
"""

stats.shapiro(mola1.forca)

estatistica, p = stats.shapiro(mola1.forca)
print('Estatística do teste: {}'.format(estatistica))
print('p-valor: {}'.format(p))

estatistica, p = stats.shapiro(mola1.deformacao)
print('Estatística do teste: {}'.format(estatistica))
print('p-valor: {}'.format(p))

"""## Correlação Linear

Pearson (distribuição normal)

Spearman (distribuição não normal)

Kendall (distribuição não normal com quantidade pequena de amostras)

Ho = não há corrrelação linear: p > 0,05

Ha = existe correlação linear: p <= 0,05
"""

# Pearson
coef,p = stats.pearsonr(mola1.deformacao,mola1.forca)
print('Coeficiente de correlação: {}'.format(coef))
print('p-valor: {}'.format(p))

# Spearman
coef,p = stats.spearmanr(mola1.deformacao,mola1.forca)
print('Coeficiente de correlação: {}'.format(coef))
print('p-valor: {}'.format(p))

# Kendall
coef,p = stats.kendalltau(mola1.deformacao,mola1.forca)
print('Coeficiente de correlação: {}'.format(coef))
print('p-valor: {}'.format(p))

correlacoes = mola1.corr(method='pearson')
correlacoes

plt.figure()
sns.heatmap(correlacoes, annot=True);

"""# **MODELO DE REGRESSÃO LINEAR**

## Regressão Linear com Statsmodels
"""

import statsmodels.formula.api as smf
import statsmodels.stats.api as sms

# Criação do modelo
regressao = smf.ols('forca ~ deformacao', data = mola1).fit()

residuos = regressao.resid
residuos

"""### Teste de Normalidade dos resíduos

Ho = distribuição normal : p > 0.05

Ha = distribuição != normal : p <= 0.05
"""

estatistica, p = stats.shapiro(residuos)
print('Estatística de teste: {}'.format(estatistica))
print('p-valor: {}'.format(p))

stats.probplot(residuos, dist="norm", plot=plt)
plt.title("Normal Q-Q plot - Resíduos")
plt.show()

# prompt: Os resíduos seriam uma reta de regressão? Se não, como seria feita um gráfico com os valores observados e com a reta de regressão da força e deformação da mola?

# Plot dos valores observados e da reta de regressão
plt.figure(figsize=(8, 6))
sns.regplot(x='deformacao', y='forca', data=mola1, line_kws={'color': 'red'})
plt.title('Força vs. Deformação com Reta de Regressão')
plt.xlabel('Deformação')
plt.ylabel('Força')
plt.show()

# prompt: O que seria a equação do modelo de regressão especificamente dentro "regressao.summary()"? Explique com palavras

A equação do modelo de regressão dentro de `regressao.summary()` representa a relação linear estimada entre a variável dependente (a força, no seu caso) e a variável independente (a deformação).  Ela é apresentada na forma:

**Força = Intercepto + Coeficiente * Deformação**

* **Intercepto:** É o valor previsto para a Força quando a Deformação é zero.  É o ponto onde a linha de regressão cruza o eixo vertical (eixo y).

* **Coeficiente (da Deformação):** Representa a mudança *estimada* na Força para cada unidade de aumento na Deformação.  Se o coeficiente for positivo, significa que à medida que a Deformação aumenta, a Força também aumenta (e vice-versa).  A magnitude do coeficiente indica a *intensidade* dessa relação.


Em outras palavras, a equação resume o modelo que o programa criou para prever a Força com base na Deformação.  O `regressao.summary()` fornece mais detalhes, incluindo os valores estimados para o intercepto e o coeficiente, além de informações estatísticas sobre a qualidade do modelo, como o R-quadrado e o p-valor.

"""**Modelo aprovado**

### **Regressão Linear**
"""

print(regressao.summary())

"""Estatística t:

Ho = coeficiente igual a zero : p > 0,05 (coeficiente não validado)

Ha = coeficiente diferente de zero: p <= 0,05 (coeficiente validado)

**Equação: Força = 0,0436 + 30,2326.deformação**

**R^2 ajustado = 0,998**
"""

regressao.params

mola1.head()

regressao.predict()

plt.scatter(y=mola1.forca, x=mola1.deformacao, color='blue', s=20, alpha=0.9)
X_plot = np.linspace(0, 0.12)
plt.plot(X_plot, X_plot*regressao.params[1] + regressao.params[0], color='r')
plt.title('Reta de regressão')
plt.ylabel('FORÇA')
plt.xlabel('DEFORMAÇÃO')
plt.show()